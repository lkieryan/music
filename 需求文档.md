一、应用启动（后端先行）                                                                                             │
│                                                                                                                      │
│  • 创建与注入偏好状态                                                                                                │
│     • Tauri 启动时调用 get_preference_state → PreferenceConfig::new                                                  │
│     • PreferenceConfig 做的事：                                                                                      │
│        • 定位配置文件 config.json（app_config_dir），若不存在则写入 {"prefs": {}} 并读入到内存 memcache              │
│        • 初始化加密密钥（Keyring），供 set_secure/get_secure 使用                                                    │
│        • 建立内部广播通道（crossbeam_channel）用于偏好变更通知                                                       │
│  • 初始化与默认值合并                                                                                                │
│     • 调用 initial(app)：                                                                                            │
│        • 若缺省键不存在则写入默认值（如 thumbnail_path、artwork_path、providers.language 等）        │
│        • 基于已持久化的偏好启动后台任务（如 scan_interval → spawn 扫描任务；启动一次全量扫描）                       │
│  • 启动偏好变更监听                                                                                                  │
│     • handle_settings_changes(app.handle()) 启动一个异步任务，消费 PreferenceConfig 的通道消息                           │
│     • 对特定键执行副作用与事件广播：                                                                                 │
│        • music_paths/exclude_music_paths → 触发扫描                                                                  │
│        • providers.instances → 重新初始化 Provider                                                                   │
│        • system_settings.launch_at_login → 切换系统自启动                                                               │
│        • scan_interval → 重置扫描任务周期                                                                            │
│        • 在 UI_KEYS 白名单的键 → 向前端 emit "settings-changed" 事件（payload: (key, value)）                      │
│                                                                                                                      │
│ 二、应用启动（前端注水与监听）                                                                                       │
│                                                                                                                      │
│                                                                                                                      │
│  • 注水（hydrate）                                                                                                   │
│     • 前端应用初始化阶段调用 loadSettings（或更优：按域批量 load_domain）从后端拉取“已合并默认”的设置值            │
│     • 把这些值写入前端的 Jotai 原子（后端驱动域建议只用“内存”原子，不持久化到 localStorage，避免双源）               │
│  • 事件监听                                                                                                          │
│     • 订阅 "settings-changed" 事件                                                                                 │
│     • 收到 (prefs., value) 后，将其映射为对应的前端字段并写入原子（注意去环：如果与当前值一致或来源标记一致则忽略）  │
│                                                                                                                      │
│ 三、页面展示（声明式渲染）                                                                                           │
│                                                                                                                      │
│  • 进入设置页时，SettingBuilder 读取 useSettingValue（Jotai 原子当前值）渲染每个控件：                               │
│     • boolean → SettingSwitch                                                                                        │
│     • string → SettingInput（必要时 type="password"）                                                                │
│     • 标题与描述由定义器（defineSettingItem）传入                                                                    │
│  • 由于原子已在启动时注水，初始 UI 值即为后端当前值（或默认值）                                                      │
│                                                                                                                      │
│ 四、用户修改（前端即时 + 后端持久）                                                                                  │
│                                                                                                                      │
│  • 交互发生时（onChange/onChecked），定义器的 onChange 执行两步：                                                    │
│     • 先 setLocal：把新值写入前端原子，UI 立即响应                                                                   │
│     • 再 save：                                                                                                      │
│        • 对一般键：调用 saveSettings('scan_interval', v) 等（为文本输入等高频事件做 debounce 150–300ms）           │
│        • 对敏感键：调用 set_secure('integration.xxx_token', v)；前端不落明文、也不广播明文                           │
│     • （可选）打一个“来源 id”防止事件回流后重复写                                                                    │
│                                                                                                                      │
│ 五、后端保存与副作用                                                                                                 │
│                                                                                                                      │
│                                                                                                                      │
│  • 对非安全键：save_selective                                                                                        │
│     • 更新 memcache（dot-path：prefs.）                                                                              │
│     • 写回 config.json（原子写／flush）                                                                              │
│     • 把 (key, value) 通过内部通道发送出去                                                                           │
│  • 对安全键：set_secure                                                                                              │
│     • 通过 ChaCha20Poly1305 + Keyring 密钥加密 value，落盘 "nonce_hex:ciphertext_hex"                                │
│     • 保存后同样按需触发副作用（是否广播取决于是否在 UI_KEYS，敏感键通常不广播）                                     │
│  • handle_settings_changes 消费通道消息：                                                                                │
│     • 命中副作用键 → 执行对应动作（扫描、Provider、系统自启动、定时任务等）                                          │
│     • 命中 UI_KEYS → emit "settings-changed" 给所有前端窗口，保证多窗口一致                                        │
│                                                                                                                      │
│ 六、前端收到事件回流                                                                                                 │
│                                                                                                                      │
│  • “settings-changed” 到达后端口                                                                                   │
│     • 做键映射（去掉 "prefs." 前缀，或通过映射表从 dot-path 还原为前端字段名）                                       │
│     • 若不同步则更新前端原子                                                                                         │
│     • UI 自动刷新为后端实际值，确保最终一致性                                                                        │
│                                                                                                                      │
│ 七、特殊结构与建议                                                                                                   │
│                                                                                                                      │
│  • dot-path 键映射                                                                                                   │
│     • 后端键使用 "prefs.x.y" 的点路径，前端建议建立集中映射表（前端字段 ↔ 后端 dot-path），或保持命名一致降低成本    │
│  • 语言与 checkbox 组                                                                                                │
│     • 后端若用数组（如 language: CheckboxPreference[]），前端偏单值（当前语言）；建议后端增加单值               │
│       active_language（或在保存时把单值转为数组，仅一个 enabled=true）                                               │
│  • 同步白名单与 UI_KEYS                                                                                              │
│     • UI_KEYS 仅包含可安全广播到前端的键                                                                             │
│     • 若有云同步需求，对“云端白名单”另行维护，避免把平台/敏感配置同步出去                                            │
│                                                                                                                      │
│ 你可以把上面流程理解为一个闭环：                                                                                     │
│                                                                                                                      │
│  • 启动：后端合并默认 → 前端注水 → 展示                                                                              │
│  • 修改：前端即时更改 → 后端持久化 → 副作用/广播 → 前端一致化  