import { invoke } from '@tauri-apps/api/core'

// TS view of selection. Optional for callers 
// â€” backend will read prefs.music.source if omitted.
export type MusicSelection = {
  mode: 'all' | 'single' | 'many'
  ids?: string[]
}

// Strong types from ts-rs bindings (generated by backend). 
// Fallback to any if not present at build time.
// Use local SDK-mirror types for search to avoid depending on generated SDK bindings
import type {
  PageInput,
  SearchQuery,
  SearchType,
  SearchSort,
} from '~/types/sdk-search'
import type { MediaContent } from '~/types/bindings'

// Frontend view of page info/result when ts-rs bindings are not regenerated yet
export interface TrackPageInfo {
  limit: number
  offset: number
  next_cursor: string | null
  total: number | null
  has_more: boolean
}
export interface TrackSearchResult {
  items: MediaContent[]
  page: TrackPageInfo
}

type MaybeSelection = { selector?: MusicSelection }

// Updated search options to match backend SearchQuery structure
export interface SearchOptions extends MaybeSelection {
  // Search query parameters
  types?: SearchType[]
  page?: PageInput
  per_type_page?: Record<SearchType, PageInput>
  sort?: SearchSort
  per_type_sort?: Record<SearchType, SearchSort>
  filters?: Record<string, string>
  provider_params?: Record<string, unknown>
}

// Unified search returning MediaContent[] (tracks only)
export async function musicSearch(term: string, opts?: SearchOptions): Promise<TrackSearchResult> {
  const searchQuery: SearchQuery = {
    query: term,
    types: opts?.types || ["Track"],
    page: opts?.page || null,
    per_type_page: opts?.per_type_page || null,
    sort: opts?.sort || null,
    per_type_sort: opts?.per_type_sort || null,
    filters: opts?.filters || {},
    provider_params: opts?.provider_params || {}
  }

  const payload: Record<string, unknown> = { searchQuery }
  if (opts?.selector) payload.selector = opts.selector
  return invoke<TrackSearchResult>('music_search', payload)
}

export async function musicStreamUrl(track: MediaContent, opts?: MaybeSelection): Promise<string> {
  const payload: Record<string, unknown> = { track }
  if (opts?.selector) payload.selector = opts.selector
  return invoke<string>('music_stream_url', payload)
}

// Convenience: build a selector from ids (runtime helper)
export function singleSelector(id: string): MusicSelection {
  return { mode: 'single', ids: [id] }
}

export function manySelector(ids: string[]): MusicSelection {
  return { mode: 'many', ids }
}

// Convenience functions for different search types
// If needed, callers can pass types in opts to hint providers/backend behavior
